<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bayesian Analysis Portfolio</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        header {
            background-color: #007bff;
            color: white;
            padding: 20px;
            text-align: center;
        }
        nav {
            background-color: #333;
            padding: 10px;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        nav ul {
            list-style-type: none;
            margin: 0;
            padding: 0;
            text-align: center;
        }
        nav ul li {
            display: inline;
            margin: 0 15px;
        }
        nav ul li a {
            color: white;
            text-decoration: none;
            font-weight: bold;
        }
        nav ul li a:hover {
            text-decoration: underline;
        }
        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background-color: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        section {
            margin-bottom: 40px;
        }
        h2 {
            color: #007bff;
        }
        .viz {
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #f9f9f9;
            margin: 20px 0;
            min-height: 600px;
        }
        code {
            background-color: #f4f4f4;
            padding: 5px;
            border-radius: 3px;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            overflow-x: auto;
            border: 1px solid #ccc;
        }
        footer {
            text-align: center;
            padding: 10px;
            background-color: #333;
            color: white;
            width: 100%;
        }
    </style>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
    <header>
        <h1>Bayesian Analysis Portfolio</h1>
        <p>Explore Bayesian inference applications across Finance, Shopping, Telecom, and Entertainment using Python, interactive Plotly visualizations, and public datasets.</p>
    </header>
    <nav>
        <ul>
            <li><a href="#scenario1">Stock Volatility</a></li>
            <li><a href="#scenario2">Customer Lifetime Value</a></li>
            <li><a href="#scenario3">Churn Prediction</a></li>
            <li><a href="#scenario4">Music Recommendations</a></li>
            <li><a href="https://github.com/hyun95roh/bayesian_analysis" target="_blank">GitHub Repo</a></li>
            <li><a href="https://ht-roh.notion.site/The-Beauty-of-Bayesian-Approach-275a6f5aefbe80b0b6d9f478403ab753?source=copy_link" target="_blank">Notion Post</a></li>
        </ul>
    </nav>
    <div class="container">
        <section id="intro">
            <h2>Introduction</h2>
            <p>This portfolio showcases Bayesian methods (Inference, MCMC, Survival Analysis, Classification, ABC) applied to real-world problems. Each scenario includes Python code (PyMC), interactive Plotly visualizations, and public datasets, all reproducible via GitHub.</p>
            <p>Navigate using the menu above. Source code and data loaders are available on <a href="https://github.com/hyun95roh/bayesian_analysis">GitHub</a>.</p>
        </section>

        <section id="scenario1">
            <h2>Scenario 1: Predicting Stock Volatility in Finance</h2>
            <p>Story: An investor uses Bayesian methods to model AAPL stock volatility, updating beliefs with daily returns and forecasting future risk.</p>
            <p>Subtopics: Bayesian Inference, MCMC Simulation.</p>
            <p>Dataset: AAPL stock data from Yahoo Finance (via yfinance).</p>
            <h3>Analysis Code</h3>
            <pre><code>
import yfinance as yf
import numpy as np
import pymc as pm
import arviz as az

df = yf.download('AAPL', start='2020-09-21', end='2025-09-21')
df['LogReturn'] = np.log(df['Close'] / df['Close'].shift(1))
returns = df['LogReturn'].dropna().values

with pm.Model() as model:
    mu = pm.Normal('mu', mu=0, sigma=0.01)
    sigma = pm.InverseGamma('sigma', alpha=2, beta=0.1)
    returns_obs = pm.Normal('returns_obs', mu=mu, sigma=sigma, observed=returns)
    pred_returns = pm.Normal('pred_returns', mu=mu, sigma=sigma, shape=30)
    trace = pm.sample(1000, tune=1000, return_inferencedata=True)

with model:
    pred_trace = pm.sample_posterior_predictive(trace, var_names=['pred_returns'])
            </code></pre>
            <h3>Interactive Visualization</h3>
            <div class="viz">
                <iframe src="volatility_viz.html" width="100%" height="600px" frameborder="0"></iframe>
            </div>
            <p>Insights: Posterior sigma narrows to ~0.02, reflecting reduced uncertainty. Predictive returns show 95% CI for 30-day forecasts. Full code in <a href="https://github.com/yourusername/bayesian-portfolio/blob/main/scenario1_volatility.py">GitHub</a>.</p>
        </section>

        <section id="scenario2">
            <h2>Scenario 2: Customer Lifetime Value in Shopping</h2>
            <p>Story: A retailer forecasts customer churn using Bayesian survival analysis to optimize retention campaigns.</p>
            <p>Subtopics: Bayesian Survival Analysis, Bayesian Inference.</p>
            <p>Dataset: UCI Online Retail II (CSV: <a href="https://raw.githubusercontent.com/RameenShahid/Online-Retail-Dataset-UCI/master/data.csv">link</a>).</p>
            <h3>Analysis Code</h3>
            <pre><code>
import pandas as pd
import pymc as pm
import arviz as az

url = "https://raw.githubusercontent.com/RameenShahid/Online-Retail-Dataset-UCI/master/data.csv"
df = pd.read_csv(url, encoding='ISO-8859-1')
df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])
df = df.dropna(subset=['CustomerID']).query('Quantity > 0')
# Compute time-to-next-purchase
df['NextPurchase'] = df.groupby('CustomerID')['InvoiceDate'].shift(-1)
df['TimeToNext'] = (df['NextPurchase'] - df['InvoiceDate']).dt.days
df['Censored'] = df['TimeToNext'].isna().astype(int)
df['TimeToNext'] = df['TimeToNext'].fillna(365)

with pm.Model() as survival_model:
    mu_alpha = pm.Normal('mu_alpha', mu=2, sigma=1)
    alpha = pm.Normal('alpha', mu=mu_alpha, sigma=1, shape=5)  # Top 5 countries
    beta = pm.Normal('beta', mu=2, sigma=1, shape=5)
    t = pm.Weibull('t', alpha=alpha[country_idx], beta=beta[country_idx], observed=times, mask=censored==0)
    trace = pm.sample(1000)
            </code></pre>
            <h3>Interactive Visualization</h3>
            <div class="viz">
                <iframe src="survival_viz.html" width="100%" height="600px" frameborder="0"></iframe>
            </div>
            <p>Insights: Survival curves vary by country; frequent buyers have longer lifetimes. Full code in <a href="https://github.com/hyun95roh/bayesian_analysis/blob/main/scenario2.py">GitHub</a>.</p>
        </section>

        <section id="scenario3">
            <h2>Scenario 3: Network Churn Prediction in Telecommunication</h2>
            <p>Story: A telecom firm classifies churn risk using Bayesian logistic regression to target retention efforts.</p>
            <p>Subtopics: Bayesian Classification, Bayesian Inference.</p>
            <p>Dataset: Kaggle Telco Churn (CSV: <a href="https://raw.githubusercontent.com/IBM/telco-customer-churn-on-icp4d/master/data/Telco-Customer-Churn.csv">link</a>).</p>
            <h3>Analysis Code</h3>
            <pre><code>
import pandas as pd
import pymc as pm
import arviz as az

url = "https://raw.githubusercontent.com/IBM/telco-customer-churn-on-icp4d/master/data/Telco-Customer-Churn.csv"
df = pd.read_csv(url)
df['TotalCharges'] = pd.to_numeric(df['TotalCharges'], errors='coerce').fillna(df['TotalCharges'].median())
df['Contract'] = df['Contract'].map({'Month-to-month': 0, 'One year': 1, 'Two year': 2})
df['Churn'] = df['Churn'].map({'Yes': 1, 'No': 0})
X = df[['tenure', 'MonthlyCharges', 'Contract']].values
y = df['Churn'].values

with pm.Model() as churn_model:
    beta = pm.Normal('beta', mu=0, sigma=2, shape=3)
    intercept = pm.Normal('intercept', mu=0, sigma=2)
    logits = pm.math.dot(X, beta) + intercept
    pm.Bernoulli('churn', logit_p=logits, observed=y)
    trace = pm.sample(1000)
            </code></pre>
            <h3>Interactive Visualization</h3>
            <div class="viz">
                <iframe src="churn_viz.html" width="100%" height="600px" frameborder="0"></iframe>
            </div>
            <p>Insights: Negative `tenure` coefficient indicates longer tenure reduces churn risk (AUC ~0.85). Threshold slider adjusts classification trade-offs. Full code in <a href="https://github.com/yourusername/bayesian-portfolio/blob/main/scenario3_churn.py">GitHub</a>.</p>
        </section>

        <section id="scenario4">
            <h2>Scenario 4: Music Genre Recommendation in Entertainment</h2>
            <p>Story: A streaming service refines recommendations using Approximate Bayesian Computation to infer latent user preferences.</p>
            <p>Subtopics: Approximate Bayesian Computation, Bayesian Inference.</p>
            <p>Dataset: Million Song Taste Profile (TXT in ZIP: <a href="http://labrosa.ee.columbia.edu/~dpwe/tmp/train_triplets.txt.zip">link</a>).</p>
            <h3>Analysis Code</h3>
            <pre><code>
        import pandas as pd
        import pymc as pm
        import pytensor
        import requests, zipfile, io
        import xarray as xr
        import numpy as np

        pytensor.config.blas__ldflags = ''
        url = "http://labrosa.ee.columbia.edu/~dpwe/tmp/train_triplets.txt.zip"
        response = requests.get(url)
        with zipfile.ZipFile(io.BytesIO(response.content)) as z:
            with z.open('train_triplets.txt') as f:
                df = pd.read_csv(f, sep='\t', names=['user', 'song', 'count'])
        df = df[df['user'].isin(df['user'].value_counts().head(100).index) & 
                df['song'].isin(df['song'].value_counts().head(100).index)]
        play_counts = df.pivot_table(index='user', columns='song', values='count', fill_value=0)
        play_counts = play_counts.reindex(index=df['user'].value_counts().head(50).index, 
                                        columns=df['song'].value_counts().head(50).index, fill_value=0).values
        play_counts_norm = play_counts / (play_counts.max() + 1e-8)

        with pm.Model() as abc_model:
            user_prefs = pm.Normal('user_prefs', mu=0, sigma=1, shape=(50, 3))
            song_features = pm.Normal('song_features', mu=0, sigma=1, shape=(50, 3))
            mu = pm.math.sigmoid(pm.math.dot(user_prefs, song_features.T))
            pm.Normal('observed_counts', mu=mu, sigma=0.1, observed=play_counts_norm)
            trace = pm.sample_smc(500, cores=4)
        posterior = az.extract(trace, combined=True)
        user_prefs_samples = np.asarray(posterior['user_prefs'].values, dtype=np.float64)
        if user_prefs_samples.shape != (2000, 50, 3):
            user_prefs_samples = user_prefs_samples.transpose(2, 0, 1)
        song_features_samples = np.asarray(posterior['song_features'].values, dtype=np.float64)
        if song_features_samples.shape != (2000, 50, 3):
            song_features_samples = song_features_samples.transpose(2, 0, 1)
        user_prefs_ds = xr.Dataset(
            {'user_prefs': (['draw', 'user', 'latent'], user_prefs_samples)},
            coords={'draw': np.arange(2000), 'user': np.arange(50), 'latent': np.arange(3)}
        )
        song_features_ds = xr.Dataset(
            {'song_features': (['draw', 'song', 'latent'], song_features_samples)},
            coords={'draw': np.arange(2000), 'song': np.arange(50), 'latent': np.arange(3)}
        )
        posterior_ds = xr.merge([user_prefs_ds, song_features_ds])
        posterior_ds.to_netcdf('music_trace.nc')
            </code></pre>
            <h3>Interactive Visualization</h3>
            <div class="viz">
                <iframe src="music_viz.html" width="100%" height="600px" frameborder="0"></iframe>
            </div>
            <p>Insights: t-SNE embeddings cluster users by preference; SMC ensures fast, reliable ABC sampling (~10-15s). Traces saved as NetCDF for reproducibility. Full code in <a href="https://github.com/yourusername/bayesian-portfolio/blob/main/scenario4_music.py">GitHub</a>.</p>
        </section>
    </div>
    <footer>
        <p>&copy; 2025 Hyuntae Roh. Powered by GitHub Pages and Python.</p>
    </footer>
</body>
</html>